<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">

<dom-module id="sp-shell">
  <template>
    <style>
    
      :host {
        display: block;
      }
      
      .hidden {
        display: none;
      }
      
    </style>
    
    <sp-upload id="uploader" class="first-open" config="{{config}}"></sp-upload>
    <sp-console id="console" class="hidden first-open" config="[[config]]"></sp-console>
    
  </template>

  <script>
    class Shell extends Polymer.Element {
      
      static get is() { return 'sp-shell'; }
      
      static get properties() { return {
        
        config: Array,
        
        opened: {
          type: String,
          value: 'upload'
        }
        
      } }
      
      constructor() {
        super();
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        window.addEventListener('open-console', this.openConsole.bind(this));
        window.addEventListener('open-uploader', this.openUploader.bind(this));
        
        this.addEventListener('clear-database', async () => {
          this.set('config', []);
          window.appState.audio = {};
          await this.saveDataToIDB('audioFiles', {});
          await this.saveDataToIDB('config', []);
          location.reload();
        });
        
        if (!window.indexedDB) {
          window.dispatchEvent(new CustomEvent('idb-check-fail'));
          return;
        }
        
        this.config = [];
        
        this.setupIDB().then(() => {
          const db = this.db;
          
          // Set error handler
          db.onerror = err => {
            console.error('Error accessing IDB', err);
            gtag('event', 'exception', {
              'description': 'Error occured when exchanging data with IDB',
              'error': err.toString(),
              'fatal': false
            });
          }
          
          // Check for currently set projects
          let dispatchedEvent = false;
          db.transaction('config').objectStore('config').openCursor().onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
              // Load the data and dispatch ready event
              this.config[Number(cursor.key)] = cursor.value;
              cursor.continue();
              if (!dispatchedEvent) {
                this._getAudio().then(e => dispatchEvent(new CustomEvent('shell-ready', { detail: { noData: false } })));
                this.openConsole({ isDataSaved: true });
                dispatchedEvent = true;
              }
            } else if (Object.keys(this.config).length === 0) {
              // Dispatch event saying that app needs data
              dispatchEvent(new CustomEvent('shell-ready', { detail: { noData: true } }));
            }
          };
        }).catch(err => {
          gtag('event', 'exception', {
            'description': 'Error occured when exchanging data with IDB',
            'error': err.toString(),
            'fatal': true
          });
          throw err;
        });
      }
      
      setupIDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('AppData', 1);
          request.onsuccess = e => { this.db = e.target.result; resolve(); };
          request.onerror = reject
          request.onupgradeneeded = e => {
            const db = this.db = e.target.result;
            db.createObjectStore('config');
            db.createObjectStore('audioFiles');
          };
        });
      }
      
      async openUploader() {
        if (this.opened = 'console' && typeof Console !== 'undefined') this.$.console.close();
        if (typeof Uploader === 'undefined') await importHref('src/sp-upload.html');
        this.$.uploader.open();
        this.opened = 'upload';
        this.$.console.classList.remove('first-open');
      }
      
      async openConsole(e) {
        if (this.opened = 'upload' && typeof Uploader !== 'undefined') this.$.uploader.close();
        if (typeof PlayerConsole === 'undefined') await importHref('src/sp-console.html');
        this.$.console.open();
        this.opened = 'console';
        this.saveDataToIDB('config', this.config);
        this.$.uploader.classList.remove('first-open');
      }
      
      async readFiles(files) {
        try {
          window.appState.audio = window.appState.audio || {};
          this.config = this.config || [];
          const awaitingReads = [];
          gtag('event', 'uploaded', {
            category: 'files',
            value: files.length
          });
          let readFromConfig = false;
          files.forEach(file => {
            const reader = new FileReader();
            if (file.type.match(/^audio/)) {
              awaitingReads.push(new Promise(r => {
                reader.onload = e => {
                  let fileName = file.name;
                  if (window.appState.audio[fileName]) {
                    let i = 1;
                    while (window.appState.audio[fileName + ' (' + i + ')']) i++;
                    fileName = fileName + ' (' + i + ')'
                  }
                  window.appState.audio[fileName] = e.target.result;
                  this._broadcastFileAdded(fileName);
                  r(fileName);
                };
                reader.readAsDataURL(file);
              }));
            } else {
              awaitingReads.push(new Promise(r => {
                readFromConfig = true;
                reader.onload = e => {
                  this._readConfigFromFile(e.target.result);
                  r();
                };
                reader.readAsText(file);
              }));
            }
          });
          await Promise.all(awaitingReads);
          if (!this.config.length) {
            this.config = this.config || [];
            Object.keys(window.appState.audio).forEach(key =>
              this.config.push({ type: 'audio', name: key.match(/(.+)\..[^\.]+$/)[1], song: key }));
            this.notifySplices('config');
          } else {
            if (!readFromConfig)
              awaitingReads.forEach(promise =>
                promise.then(key => { // Regex is picking name of the file without extension
                  this.push('config', { type: 'audio', name: key.match(/(.+)\..[^\.]+$/)[1], song: key });
                }));
          }
          if (this.$.uploader.classList.contains('hidden') || this.$.uploader.classList.contains('first-open'))
            this.openUploader();
          this.saveDataToIDB('audioFiles', window.appState.audio);
        } catch(err) {
          if (err === false) return;
          gtag('event', 'exception', {
              'description': 'file_reading_error',
              'fatal': true
            });
          throw err;
        }
      }
      
      _getAudio() {
        window.appState.audio = window.appState.audio || {};
        return new Promise(r => {
          this.db.transaction('audioFiles').objectStore('audioFiles').openCursor().onsuccess = e => {
            const cursor = e.target.result;
            if (cursor) {
              window.appState.audio[cursor.key] = cursor.value;
              cursor.continue();
            } else r();
          };
        });
      }
      
      _readConfigFromFile(jsonFile) {
        const parsed = JSON.parse(jsonFile);
        const isValid = object => {
          try {
            return object.type === 'SpectaPlayerConfigJSON-rev1' && typeof object.audio === 'object'
              && typeof object.order === 'object' ? true : false;
          } catch(err) {
            console.log('Invalid JSON provided');
            Notifier.showToast(`Config file you uploaded is invalid ðŸ˜•`);
            gtag('event', 'exception', {
              'description': 'config_parsing_error',
              'fatal': false
            });
            return false;
          }
        };
        if (isValid(parsed)) {
          const callback = clearAudio => {
            gtag('event', 'uploaded', {
              category: 'config',
            });
            clearAudio && (window.appState.audio = {});
            Object.keys(parsed.audio).forEach(key => {
              window.appState.audio[key] = parsed.audio[key];
            });
            this.config = parsed.order;
          };
          if (this.config && this.config.length) {
            Notifier.askDialog('Replace current config?', {
              innerMsg: 'You have just uploaded a new config, if you choose use it, you will lose the current one.',
              acceptText: 'Replace',
              cancelText: 'Cancel'
            }).then(() => callback(true)).catch(err => {
              if (err.error !== false) throw err;
            });
          } else callback(false);
        } else {
          console.log('Invalid JSON provided');
          Notifier.showToast(`Config file you uploaded is invalid ðŸ˜•`);
          gtag('event', 'exception', {
            'description': 'config_parsing_error',
            'fatal': false
          });
        }
      }
      
      async saveDataToIDB(database, data) {
        const dataKeys = Object.keys(data);
        const objectStore = this.db.transaction(database, 'readwrite').objectStore(database);
        const putItem = (key, value) => new Promise(r => objectStore.put(value, key).onsuccess = r);
        const removeEverything = () => new Promise(r => objectStore.clear().onsuccess = r);
        
        // Remove old values
        await removeEverything();
        
        // Write new values
        dataKeys.forEach(async key => {
          const value = data[key];
          await putItem(key, value);
        });
      }
      
      _broadcastFileAdded(fileName) {
        const detail = { type: 'audio', song: fileName, name: fileName.match(/(.+)\..[^\.]+$/)[1] };
        this.dispatchEvent(new CustomEvent('file-added', { detail, composed: true }));
      }
      
    }

    customElements.define(Shell.is, Shell);
  </script>
</dom-module>
