<link rel="import" href="../bower_components/polymer/polymer.html">

<link rel="import" href="../bower_components/paper-behaviors/paper-button-behavior.html">

<dom-module id="sp-player">
  <template>
    <style>
    
      :host {
        position: relative;
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        color: var(--primary-text-color);
        font-family: var(--main-font);
        height: 82px;
        padding: 8px 16px;
        justify-content: space-evenly;
        outline: none !important;
      }
      
      #progress-container {
        box-sizing: border-box;
        overflow: hidden;
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        left: 0;
      }
      #progress-bar {
        box-sizing: border-box;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 1px;
        transform: scaleX(0);
        transform-origin: left;
        background-color: var(--primary-color);
        opacity: 0.3;
      }
      
      #label, #filename, #progress-time {
        overflow-y: hidden;
        text-overflow: ellipsis;
        overflow-wrap: break-word;
      }
      
      #label {
        font-size: 16px;
      }
      #filename {
        font-size: 12px;
        color: var(--secondary-text-color);
        max-height: 30px;
      }
      #progress-time {
        font-size: 12px;
        font-weight: 500;
      }
      
      paper-ripple {
        color: var(--primary-color);
      }

      audio {
        display: none;
      }
      
    </style>
    
    <div id="progress-container">
      <div id="progress-bar"></div>
    </div>
    <div id="label"><slot></slot></div>
    <div id="filename">[[song]]</div>
    <div id="progress-time">0:00 / 0:00</div>
    
    <audio loop="[[loop]]" src="[[_getSong(song)]]"></audio>
  </template>

  <script>
    class Player extends Polymer.mixinBehaviors(Polymer.PaperButtonBehavior, Polymer.Element) {
      
      static get is() { return 'sp-player'; }
      
      static get properties() { return {
        
        song: String,
        
        playing: {
          type: Boolean,
          value: false,
          observer: '_notifyAboutPlayback',
          reflectToAttribute: true
        },
        
        loop: {
          type: Boolean,
          value: false
        },
        
        crossfade: {
          type: Boolean,
          value: false
        }
        
      } }
      
      constructor() {
        super();
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.setAttribute('toggles', true);
        
        if (!this._audioEl) this._audioEl = this.shadowRoot.querySelector('audio');
        if (!this._progressBar) this._progressBar = this.shadowRoot.querySelector('#progress-bar');
        if (!this._progressTime) this._progressTime = this.shadowRoot.querySelector('#progress-time');
        
        this.addEventListener('tap', this.togglePlay.bind(this));
        this._audioEl.addEventListener('ended', () => this.togglePlay(false));

        this._setDuration = () => {
          this._durationFormatted = this._toMinutes(this._audioEl.duration);
          this._progressTime.textContent = `0:00 / ${this._durationFormatted}`;
        };
        this._audioEl.addEventListener('loadedmetadata', this._setDuration.bind(this));
        
        this._dragCallbackStart = e => {
          if (window.appState.dragging) return;
          const currentX = e.clientX || e.touches[0].clientX,
                currentY = e.clientY || e.touches[0].clientY;
          this._initialDragCords = { x: currentX, y: currentY };
          window.appState.dragging = this;
        };
        this.addEventListener('mousedown', this._dragCallbackStart, { passive: true });
        this.addEventListener('touchstart', this._dragCallbackStart, { passive: true });
        
        this._dragCallbackMove = e => {
          if (!this._initialDragCords) return;
          const currentX = e.clientX || e.touches[0].clientX,
                currentY = e.clientY || e.touches[0].clientY,
                xAxis = this._initialDragCords.x - currentX,
                yAxis = this._initialDragCords.y - currentY;
          if (Math.abs(xAxis) > Math.abs(yAxis)) {
            e.preventDefault();
            const percentage = xAxis/200,
                  duration = this._audioEl.duration,
                  currentTime = this._audioEl.currentTime;
            let skipTo = currentTime - duration * percentage;
            if (skipTo > duration) skipTo = duration;
            if (skipTo < 0) skipTo = 0;
            this._skipTo = skipTo;
            requestAnimationFrame(() => {
              const width = this.getBoundingClientRect().width;
              this._progressBar.style.transform = `scaleX(${Math.round(this._skipTo / duration * width)})`;
              this._progressTime.textContent = `${this._toMinutes(skipTo)} / ${this._durationFormatted}`;
            });
          }
        };
        window.addEventListener('mousemove', this._dragCallbackMove.bind(this), { passive: false });
        window.addEventListener('touchmove', this._dragCallbackMove.bind(this), { passive: false });
        
        this._dragCallbackEnd = e => {
          if (this._skipTo) {
            const duration = this._audioEl.duration,
                  skipTo = this._skipTo;
            this._audioEl.currentTime = skipTo;
            requestAnimationFrame(() => {
              const width = this.getBoundingClientRect().width;
              this._progressBar.style.transform = `scaleX(${Math.round(skipTo / duration * width)}`;
              this._progressTime.textContent = `${this._toMinutes(skipTo)} / ${this._durationFormatted}`;
            });
          }
          this._skipTo = this._initialDragCords = window.appState.dragging = null;
        };
        window.addEventListener('mouseup', this._dragCallbackEnd.bind(this), { passive: true });
        window.addEventListener('touchend', this._dragCallbackEnd.bind(this), { passive: true });
      }
      
      disconnectedCallback() {
        if (this.playing) this.togglePlay();
        
        this.removeEventListener('tap', this.togglePlay.bind(this));

        this._audioEl.removeEventListener('loadedmetadata', this._setDuration.bind(this));
        
        this.removeEventListener('mousedown', this._dragCallbackStart, { passive: true });
        this.removeEventListener('touchstart', this._dragCallbackStart, { passive: true });
        window.removeEventListener('mousemove', this._dragCallbackMove.bind(this), { passive: false });
        window.removeEventListener('touchmove', this._dragCallbackMove.bind(this), { passive: false });
        window.removeEventListener('mouseup', this._dragCallbackEnd.bind(this), { passive: true });
        window.removeEventListener('touchend', this._dragCallbackEnd.bind(this), { passive: true });
      }
      
      togglePlay(forcedState) {
        const playState = forcedState instanceof Boolean ?
          forcedState : this._playing;
        if (playState) {
          this._notifyAboutPlayback(false);
          this._playStatus.then(async () => {
            if (this._playing) {
              if (this.crossfade)
                await this._fadeOutAudio(this._audioEl);
              this._audioEl.pause();
            }
            this._playing = false;
            this.active = false;
          });
        } else {
          this._notifyAboutPlayback(true);
          this._audioEl.volume = this.crossfade ? 0 : 1;
          this._playStatus = this._audioEl.play();
          this._playing = true;
          this.active = true;
          if (this.crossfade) this._fadeInAudio(this._audioEl);
          
          const duration = this._audioEl.duration,
                width = this.getBoundingClientRect().width,
                callback = () => {
                  if (window.appState.dragging !== this) {
                    const currentTime = this._audioEl.currentTime;
                    this._progressBar.style.transform = `scaleX(${Math.round(currentTime / duration * width)}`;
                    this._progressTime.textContent = `${this._toMinutes(currentTime)} / ${this._durationFormatted}`;
                  }
                  if (this._playing) requestAnimationFrame(callback);
                };
          requestAnimationFrame(callback);
        }
      }
      
      _getSong(song) {
        return window.appState.audio[song];
      }
      
      _notifyAboutPlayback(state) {
        this.dispatchEvent(new CustomEvent('audio' + (state ? 'played' : 'paused'),
          { bubbles: true, composed: true, detail: this }));
      }
      
      _fadeInAudio(audioEl) {
        return new Promise(r => {
          let i = 20;
          audioEl.volume = 0;
          const interval = setInterval(() => {
            audioEl.volume = (audioEl.volume * 100 + 5) / 100;
            i--;
            if (i <= 0) {
              audioEl.volume = 1;
              clearInterval(interval);
              r();
            }
          }, 100);
        });
      }
      
      _fadeOutAudio(audioEl) {
        return new Promise(r => {
          let i = 20;
          audioEl.volume = 1;
          const interval = setInterval(() => {
            audioEl.volume = (audioEl.volume * 100 - 5) / 100;
            i--;
            if (i <= 0) {
              audioEl.volume = 0;
              clearInterval(interval);
              r();
            }
          }, 100);
        });
      }

      _toMinutes(input) {
        let seconds = Math.round(input);
        const minutes = Math.floor(seconds / 60);
        seconds = seconds - minutes * 60;
        if (seconds.length !== 2) seconds = '0' + seconds;
        return `${minutes}:${seconds}`; 
      }
      
    }

    customElements.define(Player.is, Player);
  </script>
</dom-module>
